Como podrias mejorar mi readme, en mi proyecto de python que solo sera para verlo mas no modicarlo

#Estructura del proyecto

proyecto-final/
├── utils/
    ├── components/
        ├── universitys.py  
    ├── database/
        ├── json.py
    ├── menu.py      
├──main.py
├──estudiantes.json
├──README.md
├──requirements.txt


#Main.py

from utils.menu import *
from utils.database.json import cargar_datos, guardar_datos
from colorama import Fore, Style, init
import time

#CONSTANTES
EDADMINIMA = 13
EDADMAXIMA = 25
DELAY = 1

# Inicializa colorama (necesario para Windows)
init()

estudiantes = {
        "Nombre": ...,
        "Edad": 0,
        "Notas": [],
        "Cedula": 0,
    }

lista_materias = ["Biologia", "Castellano", "Fisica", "Ingles", "Matematicas", "Quimica", "GHC", "Ciencias de la Tierra", "Premilitar"]

lista_estudiantes = cargar_datos()

def main():
    """Funcion principal que se encarga de la toda la logia del programa

    """

    global lista_estudiantes

    while True:
        print(Fore.LIGHTYELLOW_EX +"\n\t\tPrograma de ingresos de estudiantes\n" + Style.RESET_ALL)
        print(Fore.CYAN + "\t\t\tMenú de Ingresos\n" + Style.RESET_ALL)
        print("\t\t 1. Estudiante")
        print("\t\t 2. Administador")
        print("\t\t 3. Salir")

        #===================================Menu de Opciones=====================================================
        try:
            opcion = int(input("\nSeleccione una opcion: "))
        except ValueError:
            print(Fore.RED + "Error: Por favor ingrese un número válido" + Style.RESET_ALL)
            time.sleep(DELAY)
            continue

        """Ejecuta la opcion de estudiante, crear un estudiante con los datos del datos"""
        if opcion == 1:

            time.sleep(DELAY)
            print(Fore.CYAN + "\n\tColoque sus datos\n" + Style.RESET_ALL)

            #Crea una copia del diccionario 
            estudiante_actual = estudiantes.copy()
            estudiante_actual["Notas"].clear()

            estudiante_actual["Nombre"] = input("Hola usuario porfavor coloque su nombre: ")

            #Verificacion de la edad del usuario sin que el programa termine
            while True:
                try:
                    edad = int(input("Ahora porfavor coloque su edad: "))
                    verificar_edad(edad)
                    estudiante_actual["Edad"] = edad
                    break
                except (ValueError, TypeError, Exception) as e:
                    print(f"\nError: {e}")

            estudiante_actual["Cedula"] = input("Por favor coloque su cédula: ")

            #Verificacion de las notas del usuario sin que el programa termine
            for materia in lista_materias:
                while True:
                    try:
                        nota = int(input(f"\nColoque la nota de {materia}: "))
                        verificar_notas(nota)
                        estudiantes["Notas"].append(nota)
                        break
                    except (ValueError, TypeError, Exception) as e:
                        print(Fore.RED + f"\nError: {e}" + Style.RESET_ALL)

            #Nota final del estudiante
            nota_final = calcular_nota(estudiante_actual["Notas"])

            time.sleep(DELAY)  
            carrera_estudiante = mostrar_menu_universidades()

            #==========Imprimir datos del estudiante===========
            print("")
            print(Fore.CYAN + "\t\tDatos del Estudiante" + Style.RESET_ALL )

            for clave, valor in estudiante_actual.items():
                #Imprime la lista de notas como un STR(string)
                if isinstance(valor, list):
                    valor_str = ', '.join(map(str, valor))
                    print(Fore.BLUE + f"{clave}: " + Fore.GREEN + f"{valor_str}")
                else:
                    print(Fore.BLUE + f"{clave}: " + Fore.GREEN + f"{valor}" + Style.RESET_ALL)

            #Imprime la nota global y la carrera seleccionada
            print(Fore.BLUE + f"Nota Global: " + Fore.GREEN + f"{nota_final:.2f}" + Style.RESET_ALL)
            print(Fore.BLUE + f"Carrera seleccionada: " + Fore.GREEN + f"{carrera_estudiante}" + Style.RESET_ALL)


            #Guardar datos del estudiante
            estudiante_actual["Nota Global"] = nota_final
            estudiante_actual["Carrera"] = carrera_estudiante
            lista_estudiantes.append(estudiante_actual)
            guardar_datos(lista_estudiantes) #Guardar al JSON

            #Volver a inicio
            input(Fore.YELLOW + "\nPresione Enter para volver al menú principal..." + Style.RESET_ALL)

        # ===================================Opción Administrador==================================
        elif opcion ==2:
            password = input(Fore.YELLOW + "\nColoque la clave de administrador: " + Style.RESET_ALL).lower().strip()

            if password == "admin123":

                lista_estudiantes = cargar_datos()
            
                print("\n\tMenú de Administracion\n")
                print("\t1. Ver la lista de estudiantes.")
                estudiantes_registrados(lista_estudiantes)

                try:
                    opcion_admin = int(input("\nSeleccione una opcion: "))
                except ValueError:
                    print(Fore.RED + "Error: Por favor ingrese un número válido" + Style.RESET_ALL)
                    time.sleep(DELAY)
                    continue

                if opcion_admin == 1:
                #Muestra los datos del estudiante
                    mostrar_lista_estudiantes(lista_estudiantes)
                else: 
                    print(Fore.RED + "Opcion no valida" + Style.RESET_ALL)
            
            else:
                print("Clave incorrecta")

            #Volver a inicio
            input(Fore.YELLOW + "\nPresione Enter para volver al menú principal..." + Style.RESET_ALL)

        # =================================== Salir ===================================
        elif opcion == 3:
            time.sleep(DELAY + DELAY)
            print("Saliendo.....")
            break

        else:
            print(Fore.RED + "Opción no válida" + Style.RESET_ALL)
            time.sleep(DELAY)

"""
    FUNCIONES
"""
#Funciones de verificacion
def verificar_edad(edad: int):
    """Verifica que la edad cumpla con los requisitos establecidos.
    
    Valida que la edad esté dentro del rango permitido (13-19 años) y que sea
    del tipo de dato correcto (entero).

    Args:
        edad (int): Edad del estudiante a validar

    Raises:
        ValueError: Si la edad está fuera del rango permitido (13-19)
        TypeError: Si el tipo de dato no es entero
    """

    if edad < EDADMINIMA or edad > EDADMAXIMA:
        raise ValueError(Fore.RED + "La edad no puede ser menor a 13 o mayor a 19. Porfavor intente de nuevo.\n" + Style.RESET_ALL)
    if isinstance(edad, str):
            raise TypeError(Fore.RED + "La edad no pueden ser texto\n" + Style.RESET_ALL)


def verificar_notas(nota: int):
    """Verifica que la nota cumpla con los requisitos establecidos.
    
    Valida que la nota esté dentro del rango permitido (0-20) y que sea
    del tipo de dato correcto (entero).

    Args:
        nota (int): Nota del estudiante a validar

    Raises:
        ValueError: Si la nota está fuera del rango permitido (0-20)
        TypeError: Si el tipo de dato no es entero
    """
    if nota < 0 or nota > 20:
        raise ValueError("Las notas deben estar entre 0 y 20.\n" + Style.RESET_ALL)
        
    if isinstance(nota, str):
        raise TypeError("Las notas no pueden ser texto\n" + Style.RESET_ALL)
    
def calcular_nota(notas: list) -> float:
    """Calcula el promedio de una lista de notas del estudiante.
    
    Toma una lista de notas numéricas y devuelve el promedio en decimales.

    Args:
        notas (list): Lista de notas numéricas

    Returns:
        float: Promedio de las notas con precisión decimal

    """
    
    return sum(notas) / len(notas)

def mostrar_lista_estudiantes(estudiantes: list):
    """Muestra en pantalla la lista de estudiantes registrados.
    
    Presenta de forma ordenada la información de todos los estudiantes
    en el formato: nombre, edad, cédula y nota global.

    Args:
        estudiantes (list): Lista de diccionarios con información de estudiantes.
                            Cada diccionario debe contener las claves:
                            'Nombre', 'Cedula', 'Edad', 'Nota Global'
    """

    print("\nLista de estudiantes:")
    for i, estudiante in enumerate(estudiantes, 1):
        print(Fore.BLUE + f"\n{i}. Nombre: " + Fore.GREEN + f"{estudiante["Nombre"]}, " + Fore.BLUE + f"Cédula: " + Fore.GREEN + f"{estudiante["Cedula"]}, " + Fore.BLUE + f"Nota Global: " + Fore.GREEN + f"{estudiante['Nota Global']:.2f}")


def estudiantes_registrados(lista_estudiantes: list):
    """Muestra el total de estudiantes registrados.
    
    Presenta el conteo total de estudiantes en color amarillo.

    Args:
        lista_estudiantes (list): Lista de estudiantes registrados
    """

    print(Fore.MAGENTA + f"\tTotal de estudiantes registrados: {len(lista_estudiantes)}" + Style.RESET_ALL)


if __name__ == '__main__':
    main()



#menu.py

from .components.universitys import obtener_universidades, obtener_tipos_carreras, obtener_carreras_por_tipo
from colorama import Fore, Style, init
import time

# Inicializa colorama (necesario para Windows)
init()

DELAY = 1

#Funciones para el menu
def mostrar_menu_universidades():
    """Muestra el menú principal de selección de universidades.
    
    Presenta una interfaz interactiva que permite al usuario seleccionar
    entre las universidades disponibles o salir del programa. Navega
    a través de los submenús de tipos de carrera y carreras específicas.

    Returns:
        str or None: Nombre de la carrera seleccionada por el usuario.
                Retorna None si el usuario elige salir o cancela la selección.
    """

    universidades = obtener_universidades()
    
    while True:
        print(Fore.YELLOW + "\n\t\tMenú de Universidades" + Style.RESET_ALL)
        for i, uni in enumerate(universidades, 1):
            print(f"\t{i}. {uni['nombre']}")
        print(Fore.RED + "\t5. Salir" + Style.RESET_ALL)
        
        try:
            opcion = int(input("\nSeleccione una universidad: "))
            if opcion == 5:
                print("Programa finalizada.")
                return None
            elif 1 <= opcion <= 4:
                universidad_seleccionada = universidades[opcion-1]
                carrera_seleccionada = mostrar_menu_tipos_carreras(universidad_seleccionada)
                if carrera_seleccionada:
                    return carrera_seleccionada
            else:
                print("Opción inválida. Intente de nuevo.")
        except ValueError:
            print("Por favor, ingrese un número válido.")



def mostrar_menu_tipos_carreras(universidad):
    """Muestra el menú de tipos de carrera para una universidad específica.
    
    Presenta las categorías de carreras disponibles en la universidad
    seleccionada y permite navegar al menú de carreras específicas.

    Args:
        universidad (dict): Diccionario con la información de la universidad
                    seleccionada. Debe contener las claves 'nombre' y 'carreras'.

    Returns:
        str or None: Nombre de la carrera seleccionada por el usuario.
                    Retorna None si el usuario elige volver al menú anterior.
    """

    tipos_carrera = obtener_tipos_carreras(universidad)

    time.sleep(DELAY) 
    
    while True:
        print(Fore.YELLOW + f"\n\t\tTipos de Carrera en {universidad['nombre']}" + Style.RESET_ALL)
        for i, tipo in enumerate(tipos_carrera, 1):
            print(f"{i}. {tipo}")
        print(f"{len(tipos_carrera)+1}. Volver al menú anterior")
        
        try:
            opcion = int(input("\nSeleccione un tipo de carrera: "))
            if opcion == len(tipos_carrera)+1:
                return None
            elif 1 <= opcion <= len(tipos_carrera):
                tipo_seleccionado = tipos_carrera[opcion-1]
                carrera_seleccionada = mostrar_carreras(universidad, tipo_seleccionado)
                if carrera_seleccionada:
                    return carrera_seleccionada
            else:
                print("Opción inválida. Intente de nuevo.")
        except ValueError:
            print("Por favor, ingrese un número válido.")



def mostrar_carreras(universidad, tipo_carrera):
    """Muestra la lista de carreras específicas de un tipo en una universidad.
    
    Presenta todas las carreras disponibles dentro de una categoría específica
    y permite al usuario seleccionar una por su ID.

    Args:
        universidad (dict): Diccionario con la información de la universidad.
        tipo_carrera (str): Tipo o categoría de carreras a mostrar.

    Returns:
        str or None: Nombre de la carrera seleccionada por el usuario.
                    Retorna None si el usuario elige volver al menú anterior.

    """

    time.sleep(DELAY) 


    carreras = obtener_carreras_por_tipo(universidad, tipo_carrera)
    
    print(Fore.YELLOW + f"\n\t\t{tipo_carrera} en {universidad['nombre']}" + Style.RESET_ALL)
    for carrera in carreras:
        print(f"{carrera['id']}: {carrera['name']}")
    
    while True:
        try:
            opcion = int(input("\nIngrese el ID de la carrera que desea seleccionar (0 para volver): "))
            if opcion == 0:
                return None
            for carrera in carreras:
                if carrera['id'] == opcion:
                    print(f"La carrera seleccionada es: {carrera["name"]}")
                    carrera_estudiante = carrera["name"] 
                    return carrera_estudiante
                    
            print("ID no encontrado. Intente de nuevo.")
        except ValueError:
            print("Por favor, ingrese un número válido.")


#universitys.py


UDO = {
    "nombre": "Universidad de Oriente (UDO) - Núcleo Monagas",
    "ubicacion": "Av. Universidad, Sector Jusepín, Maturín, estado Monagas",
    "carreras": {
        "Ingenierías": [
            {"name": "Ingeniería Agronómica", "id": 1},
            {"name": "Ingeniería de Petróleo", "id": 2},
            {"name": "Ingeniería de Gas", "id": 3},
            {"name": "Ingeniería Geológica", "id": 4},
            {"name": "Ingeniería Geofísica", "id": 5},
            {"name": "Ingeniería de Mantenimiento Mecánico", "id": 6},
            {"name": "Ingeniería Eléctrica", "id": 7},
            {"name": "Ingeniería Electrónica", "id": 8},
            {"name": "Ingeniería en Sistemas", "id": 9},
            {"name": "Ingeniería Informatica", "id": 10}
        ],
        "Otros": [
            {"name": "Medicina", "id": 1},
            {"name": "Enfermería", "id": 2},
            {"name": "Bioanálisis", "id": 3},
            {"name": "Salud Pública", "id": 4},
            {"name": "Administración", "id": 5},
            {"name": "Contaduría Pública", "id": 6},
            {"name": "Estudios Internacionales", "id": 7},
            {"name": "Relaciones Industriales", "id": 8},
            {"name": "Turismo", "id": 9}
        ]
    }
}




UNEFA = {
    "nombre": "Universidad Nacional Experimental Politécnica de la Fuerza Armada Nacional Bolivariana (UNEFA) - Núcleo Monagas",
    "ubicacion": "Av. Raúl Leoni, Sector Los Guaritos, Maturín, estado Monagas",
    "carreras": {
        "Ingenierías": [
            {"name":"Ingeniería de Sistemas", "id": 1},{"name":"Ingeniería Electrónica", "id": 2},{"name":"Ingeniería Mecánica", "id": 3},{"name":"Ingeniería Civil", "id": 4},{"name":"Ingeniería de Petróleo", "id": 5}
        ],
        "Licenciaturas": [
            {"name":"Licenciatura en Administración", "id": 1},
            {"name":"Licenciatura en Contaduría Pública", "id": 2}
        ]
    }
}


IUTIRLA = {
    "nombre": "Instituto Universitario de Tecnología Industrial Rodolfo Loero Arismendi (IUTIRLA) - Núcleo Maturín",
    "ubicacion": "Avenida Bolívar, Sector Los Guaritos, Maturín, Estado Monagas",
    "carreras": {
        "Ingeniería": [
            {"name": "Ingeniería Eléctrica", "id": 1},
            {"name": "Ingeniería Electrónica", "id": 2},
            {"name": "Ingeniería Mecánica", "id": 3}
        ],
        "Tecnico Superior Universitario": [
            {"name": "Informatica", "id": 1},
            {"name": "Diseño Grafico", "id": 2},
            {"name": "Administracion de Empresas", "id": 3},
            {"name": "Turismo", "id": 4}
        ],
        
    }
}

UNES = {
    "nombre": "Universidad Nacional Experimental de la Seguridad (UNES) - Sede Maturín",
    "ubicacion": "Calle Cumaná con Calle Caicara, frente a la Redoma El Indio, Parroquia Alto de los Godos, Maturín",
    "carreras": {
        "Otros":[
            {"name": "Formación para Oficiales de Seguridad", "id": 1},
            {"name": "Investigación Penal", "id": 2},
            {"name": "Prevención y Gestión de Riesgos", "id": 3}
        ]
    }
}

"""
    Funciones
"""

#Funciones Gets
def obtener_universidades():
    """Obtiene la lista de todas las universidades disponibles en el sistema.
    
    Retorna un listado con los diccionarios que contienen la información completa
    de cada universidad registrada, incluyendo UDO, UNEFA, IUTIRLA y UNES.

    Returns:
        list: Lista de diccionarios con la información de las universidades.
            Cada diccionario contiene las claves: 'nombre', 'ubicacion' y 'carreras'

    """
    return [UDO, UNEFA, IUTIRLA, UNES]


def obtener_tipos_carreras(universidad):
    """Obtiene los tipos o categorías de carreras disponibles en una universidad.
    
    Cada universidad organiza sus carreras en categorías como "Ingenierías", 
    "Licenciaturas" y "Otros" Esta función devuelve las categorías
    disponibles para la universidad especificada.

    Args:
        universidad (dict): Diccionario que representa una universidad, debe contener
                la clave 'carreras' con un diccionario de categorías.

    Returns:
        list: Lista de strings con los nombres de las categorías de carreras.
    """
    return list(universidad['carreras'].keys())


def obtener_carreras_por_tipo(universidad, tipo):
    """Obtiene la lista de carreras de una categoría específica en una universidad.
    
    Devuelve todas las carreras pertenecientes a un tipo específico (categoría)
    dentro de una universidad determinada.

    Args:
        universidad (dict): Diccionario que representa una universidad.
        tipo (str): Tipo o categoría de carreras a consultar (ej: "Ingenierías", "Otros")

    Returns:
        list: Lista de diccionarios con las carreras del tipo especificado.
            Cada diccionario contiene las claves: 'name' y 'id'
            Retorna lista vacía si el tipo no existe.

    """
    return universidad['carreras'].get(tipo, [])



#json.py


import json

#CONSTANTES
ARCHIVO_JSON = 'estudiantes.json'

# Cargar datos existentes al iniciar
def cargar_datos():
    """
    Carga los datos de estudiantes desde el archivo JSON.
    
    Intenta leer el archivo especificado en la variable ARCHIVO_JSON. Si el archivo
    no existe, retorna una lista vacía para inicializar los datos.
    
    Returns:
        list: Una lista de diccionarios con los datos de los estudiantes cargados desde el archivo JSON. Retorna una lista vacía si el archivo no existe.
        
    """
    try:
        with open(ARCHIVO_JSON, 'r') as archivo:
            return json.load(archivo)
    except FileNotFoundError:
        return []
    
# Guardar datos en el archivo JSON
def guardar_datos(datos):
    """
    Guarda los datos de estudiantes en el archivo JSON.
    
    Escribe los datos proporcionados en el archivo especificado en la variable ARCHIVO_JSON
    con formato indentado para mejor legibilidad.
    
    Args:
        datos (list): Lista de diccionarios con los datos de estudiantes a guardar.
        
    
    """

    with open(ARCHIVO_JSON, 'w') as archivo:
        json.dump(datos, archivo, indent=4)